### 중복된 값을 가진 Node 모두 제거하기
- runner 포인터를 만들어 순회하며 제거한다.
  - [투포인터 알고리즘](https://www.geeksforgeeks.org/dsa/two-pointers-technique/)
- (참고)
```cpp
if(..) {
    ...
    node->next = node->next->next;
} else {
    node = node->next;
}
```

### 끝에서 k 번째 node 검색
[재귀](https://www.geeksforgeeks.org/dsa/introduction-to-recursion-2/)를 사용한다.

### Singly Linked List에서 현재 Node를 제거하기
- 다음 Node의 데이터를 현재 Node에 복사 후 다음 Node를 제거한다.
- Array에서 중간 요소를 제거할 때와 동일한 메커니즘

### x를 기준으로 작은 것은 왼쪽, 큰 것은 오른쪽으로 나누기
- LinkedList를 두개 사용한다.
- LinkedList에 있는 데이터를 외부에서 다루기 위해 데이터를 반환해야한다. (현재까지는 로그만 출력함)

> node->next = nullptr;  // node가 마지막 node가 되어야하는 경우 next를 nullptr로 만들어야한다.



### SUM
Note..
- sum_v3: 재귀에서 연산을 먼저 완료하고나서 재귀하는 순서가 헷갈렸다.
- **append 매개변수 자료형**
이전까지는 LL 하나가 연속적으로 append해서 문제없었던 것, 지금은 여러 LL이 각자 append를 하는 방식이기 때문에 값이 아닌 Node를 인자로 받아야한다.
LL을 구현하는 것이 아닌 사용자 입장에서는 Node 자료형을 몰라도 된다고 생각이 되는데 그렇다면 결국 append 오버라이딩

### 두 리스트 사이의 교차점 찾기
1. 각각 순회하여 마지막 노드가 동일하면 교차점이 있는 것
2. 두 리스트의 길이를 동일하게 한다. (짧은 쪽에 노드를 추가하거나, 그 반대도 가능)
3. 두 리스트를 동시에 순회한다.
4. 동일한 노드가 나오면 해당 노드가 교차점이다.

### 루프 찾기
1. 거북이와 토끼. 거북이는 1칸 씩, 토끼는 2칸 씩 이동한다.
2. 둘이 만나면 루프가 존재하는 것, 아니면 루프가 없다. **(루프 존재 여부)**
3. 만난 지점을 기점으로 다시 돌아올때까지 1칸 씩 이동하면 **루프 길이**를 구할 수 있다.
4. 거북이만 처음 위치에 두고 다시 둘이 만날때 까지 이동시킨다.
5. **거북이가 루프 진입점에 도착했을때 거북이와 토끼 사이의 거리를 x라고한다.**
6. x가 루프 길이의 2/1 보다 작으면 토끼는 한바퀴 이상을 돈다.
7. 토끼가 1바퀴 이상 돌면 토끼의 걸음수를 루프 길이로 나눴을때의 몫에 2를 곱하면 x다?.
8. 