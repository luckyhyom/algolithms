### 중복된 값을 가진 Node 모두 제거하기
- runner 포인터를 만들어 순회하며 제거한다.
  - [투포인터 알고리즘](https://www.geeksforgeeks.org/dsa/two-pointers-technique/)
- (참고)
```cpp
if(..) {
    ...
    node->next = node->next->next;
} else {
    node = node->next;
}
```

> [!NOTE]
> 1. 추가 버퍼를 사용하면 시간 복잡도 O(N), 공간 복잡도 O(N)
> 2. 위의 알고리즘은 추가 버퍼를 사용하지 않고 데이터 정렬이 되지 않은 상태에서 적용한다.
>    시간 복잡도 O(N^2), 공간 복잡도 O(1)


### 끝에서 k 번째 node 검색
[재귀](https://www.geeksforgeeks.org/dsa/introduction-to-recursion-2/)를 사용한다.

### Singly Linked List에서 현재 Node를 제거하기
- 다음 Node의 데이터를 현재 Node에 복사 후 다음 Node를 제거한다.
- Array에서 중간 요소를 제거할 때와 동일한 메커니즘

### x를 기준으로 작은 것은 왼쪽, 큰 것은 오른쪽으로 나누기
- LinkedList를 두개 사용한다.
- LinkedList에 있는 데이터를 외부에서 다루기 위해 데이터를 반환해야한다. (현재까지는 로그만 출력함)

> node->next = nullptr;  // node가 마지막 node가 되어야하는 경우 next를 nullptr로 만들어야한다.



### SUM
Note..
- sum_v3: 재귀에서 연산을 먼저 완료하고나서 재귀하는 순서가 헷갈렸다.
- **append 매개변수 자료형**
이전까지는 LL 하나가 연속적으로 append해서 문제없었던 것, 지금은 여러 LL이 각자 append를 하는 방식이기 때문에 값이 아닌 Node를 인자로 받아야한다.
LL을 구현하는 것이 아닌 사용자 입장에서는 Node 자료형을 몰라도 된다고 생각이 되는데 그렇다면 결국 append 오버라이딩

### 두 리스트 사이의 교차점 찾기
1. 각각 순회하여 마지막 노드가 동일하면 교차점이 있는 것
2. 두 리스트의 길이를 동일하게 한다. (짧은 쪽에 노드를 추가하거나, 그 반대도 가능)
3. 두 리스트를 동시에 순회한다.
4. 동일한 노드가 나오면 해당 노드가 교차점이다.

### 루프 찾기
1. 거북이와 토끼. 거북이는 1칸 씩, 토끼는 2칸 씩 이동한다.
2. 둘이 만나면 루프가 존재하는 것, 아니면 루프가 없다. **(루프 존재 여부)**
3. 만난 지점을 기점으로 다시 돌아올때까지 1칸 씩 이동하면 **루프 길이**를 구할 수 있다.
4. 거북이만 처음 위치에 두고 다시 둘이 만날때 까지 이동시킨다.
5. **거북이가 루프 진입점에 도착했을때 거북이와 토끼 사이의 거리를 x라고한다.**
6. x가 루프 길이의 2/1 보다 작으면 토끼는 한바퀴 이상을 돈다.
7. 토끼가 1바퀴 이상 돌면 토끼의 걸음수를 루프 길이로 나눴을때의 몫에 2를 곱하면 x다?.

---
확실한 것
0. 거북이와 토끼 모두 이동을 완료했을 때 기준으로 위치가 같아야한다.
1. 직선거리 k는 거북이와 토끼 모두 동일한 거리를 이동한다.
2. 둘간의 거리 차이가 발생하는 곳은 루프이다. (루프에서 얼만큼 이동했는가)
3. 둘이 만났을 때의 위치 = M
4. 이동거리 = 2T = R
5. M = 2T = R
6. (둘이 만났을 때의 거리 차이는 무조건 루프 단위라고 한다. 이해 잘 안감)
7. 토끼는 거북이를 무시하고 지나갈 수 없다.
   1. 거북이 위치 = i, 토끼 위치 = i + 1
   2. 한 걸음 뒤로 가면
   3. i+(-1) = (i+1)+(-2) = i-1, i-1

결론
1. 거북이가 루프 진입 노드에 있을때 거북이와 토끼의 이동 거리는 각각 거북이 k, 토끼 2k가 다.
2. 거북이는 entry에 있고 토끼는 entry로 부터 k 거리 이동했다.
3. 루프 길이를 y라고 한다.
4. 토끼가 entry에서 이동한 거리와, 실제 위치의 차이는 다르다. 토끼의 entry로 부터 거리는 k/y의 나머지이다.
5. 나머지는 z라고 한다.
6. entry의 위치는 0, 토끼의 위치는 entry로부터 +z이다.
7. 토끼는 entry로 다시 돌아가기까지 (y - z) 거리가 남았다.
8. 거북이는 entry에 있으므로 토끼가 거북이를 따라잡기 위한 관점으로 토끼와 거북이의 거리 차이는 y-z다.
9.  토끼는 한 걸음에 거북이와의 거리 차이를 1씩 좁힐 수 있다. 그럼 (y-z) 걸음을 가야한다.
10. (y-z) 걸음 후에 거북이는 y-z거리 이동, 토끼는 (y-z)/2 거리 이동한다.
11. 거북이와 토끼가 만난 위치를 M이라고 한다.
12. entry에서 M까지 y-z 이동하였으므로 다시 entry에 가기까지 z 거리 남았다.
13. 즉, M의 위치는 entry로부터 -z이다.
14. (-z) + (+z) = 0이므로, z만큼 이동하면 entry에 위치할 수 있다.
15. z의 값은 무엇인가? z = k/y의 나머지다. -> 이것이 k만큼 이동했을때 어떻게 증명해야하지?
    1.  k/y의 나머지는 z다.
    2.  위에서 entry 즉, **루프 안의 특정 위치에서 k만큼 이동하면 특정 위치로부터 +z의 위치로 이동 한다**는 것을 확인함.
    3.  즉, 토끼가 M에서 k만큼 이동하면 결국 위치는 M으로부터 +z다.
    4.  M은 entry로부터 거리가 -z 였다.
    5.  (-z)+(+z) = 0이다.


> M+k≡−z+(qy+z)=qy≡0(mod y)

모듈러 산술(modular arithmetic) = “어느 숫자까지 가면 다시 0으로 돌아가는 계산 방식”.

> 1. 방식  자체: 대수(Algebra) + 논리/증명
> 대수(Algebra): 문자를 써서 일반적인 관계를 다루는 수학
> 수학적 증명 / 수리 논리: “모든 경우에 대해 항상 참이다”를 보여주는 방식
> “특정 숫자에 대해 맞는지”가 아니라 “모든 숫자에 대해 맞다를 보이는 거”
> 2. 이번 플로이드 증명에서 쓰인 내용: 정수론 + 이산수학
> 정수론(수론, Number Theory)
> 배수, 약수, 나머지, mod 연산
> 이게 컴공 쪽에선 보통
> → 이산수학(Discrete Mathematics) 챕터 안에 들어가.


> [!NOTE]
> “‘모든 경우에 대해 항상 맞는 원리로 설명/증명’하려면 대수적인 수학이 필요하다”
>
> 특정 값에 대해서만 기대 값이 나오는 것을 증명하는 방식은 테스트 코드 없는 코드와 같은 느낌이다.
> 이러한 수학적 증명 과정 없이는 어떠한 알고리즘 또는 현실 세계의 현상을 완전히 이해하기 어렵다고 생각된다..