### 자료형
컴퓨터가 데이터를 어떻게 처리해야할지 정의하는 것
자료형마다 연산 방식이 달라진다.

> 1. boolean
> 2. char
> 3. int
> 4. float / double / decimal

### Node
자료 구조에서 최소 단위의 요소(Element)로써 종종 정의된다. 자료 구조마다 Node의 구성 요소는 달라질 수 있다.

자료 구조는 하나의 박스와 박스 안의 데이터로 구성된다.
박스 안의 데이터가 기본 자료형인 경우도 있고 여러 속성을 가진 Node일 수도 있다.

## 선형 데이터 구조
데이터 구조를 구성하는 요소가 순차적으로 정렬되어있는 것을 선형 데이터 구조라고 한다.

### Array
1. **자료형이 같은 요소들을 저장한다.** (Array에 포함된 데이터를 요소(Element)라고 한다.)
2. 데이터가 메모리에 연속적으로 저장되어있는 자료 구조이다.
3. 연속적으로 저장되어있기 때문에 각 요소에는 순서가 존재하며 이를 index라고 한다.
4. index를 사용하여 특정 위치의 요소를 바로 조회할 수 있다.
5. 요소들의 순차적 구성때문에 데이터를 추가하거나 제거할 때에 배열 내의 데이터 순서를 다시 메겨야하므로 시간이 오래걸린다는 한계가 존재한다.
6. 배열의 크기를 미리 예약해야한다. (크기가 고정되며, 크기 수정 시 완전히 제거 후 다시 만들어야한다.)



### Linked List
배열의 한 유형이지만, Linked List의 요소는 흩어진 상태로 메모리에 저장된다.
리스트의 요소는 데이터 요소와 포인터의 쌍으로 구성되며 "노드"라고 한다.
> Link: 🔗 (사슬), 즉 원소가 사슬로 연결된 배열이다. 떨어져있지만 연결되어 있다는 뜻

연결 리스트의 특정 요소에 접근하려면 바로 이전 원소의 포인터를 사용해야한다.
연결 리스트는 해당 리스트에 *진입하는 지점이 있도록 구성*되며 이러한 진입점을 "헤드"라고 한다.

**사이즈가 고정된 Array와 다르게 사이즈 정해져 있지 않으며 메모리 동적 할당을 위해 개발된 자료구조다.**
순차 접근이므로 **조회는 비교적 느리지만 삽입/제거에 효율적이다.**
> 사이즈를 수정할 수 있는 Array는 Vector라고하며 Vector 역시 요소를 추가하거나 제거할 때 메모리 재할당이라는 오버헤드가 존재함
>
> *Head는 왜 필요한가?*
> 전체 Node를 모아두는 박스 역할도 하지만, 다음 Node로 접근하다보면 nullptr에 도달하여 결국 해당 Node에대한 진입점을 잃어버려 Node에 다시 접근할 수 없게 된다.
> Linked List라는 박스를 만들고 진입점을 저장해둔다.

> 1. 자료구조 탄생 역사 확인해보기
> 2. Head는 필수 불가결한가?


### Queue
Queue는 각 요소에 *우선순위를 부여하는 데이터 구조*의 한 종류다.

Enqueue (추가)                       Dequeue(제거)
------------> [Rear][][][][][Front] ----------->

> 우선순위를 부여한다는 의미는 고정된 삽입/제거 메커니즘을 인터페이스로서 제공한다는 뜻이다.\
> 중간 요소를 사용자가 직접 제어할수 없고 오직 push/pop 메서드로만 요소를 추가/제거 할 수 있다.


### Graph
Graph는 "관계"라는 개념을 표현하기 위해 정의된 자료구조다. 또는 "위치"라는 개념을 표현할 수도 있다.\
Node에는 여러개의 간선이 존재할 수 있으며 인물 관계, 지리, 모형, 등을 표현할 수 있다.

> [!Note]
> 1. 언제 필요할까? 요소가 여러 요소와 연결되어 있을 때?
> 2. bfs / dfs는 brute force같은 느낌.. 더 효율적인 알고리즘이 (A), (B)



### References
- 코드 없는 알고리즘과 데이터 구조 (암스트롱 수베로)